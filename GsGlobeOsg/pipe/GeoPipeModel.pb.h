// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GeoPipeModel.proto

#ifndef PROTOBUF_GeoPipeModel_2eproto__INCLUDED
#define PROTOBUF_GeoPipeModel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace GEOPIPEMODEL {
class PIPE;
class PIPEDefaultTypeInternal;
extern PIPEDefaultTypeInternal _PIPE_default_instance_;
class PIPETile;
class PIPETileDefaultTypeInternal;
extern PIPETileDefaultTypeInternal _PIPETile_default_instance_;
class StringTable;
class StringTableDefaultTypeInternal;
extern StringTableDefaultTypeInternal _StringTable_default_instance_;
}  // namespace GEOPIPEMODEL

namespace GEOPIPEMODEL {

namespace protobuf_GeoPipeModel_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_GeoPipeModel_2eproto

enum enumGeometryType {
  ePoint = 0,
  eLine = 1
};
bool enumGeometryType_IsValid(int value);
const enumGeometryType enumGeometryType_MIN = ePoint;
const enumGeometryType enumGeometryType_MAX = eLine;
const int enumGeometryType_ARRAYSIZE = enumGeometryType_MAX + 1;

enum enumScetionType {
  eCircle = 0,
  eSquare = 1
};
bool enumScetionType_IsValid(int value);
const enumScetionType enumScetionType_MIN = eCircle;
const enumScetionType enumScetionType_MAX = eSquare;
const int enumScetionType_ARRAYSIZE = enumScetionType_MAX + 1;

// ===================================================================

class PIPE : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GEOPIPEMODEL.PIPE) */ {
 public:
  PIPE();
  virtual ~PIPE();

  PIPE(const PIPE& from);

  inline PIPE& operator=(const PIPE& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PIPE(PIPE&& from) noexcept
    : PIPE() {
    *this = ::std::move(from);
  }

  inline PIPE& operator=(PIPE&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PIPE& default_instance();

  static inline const PIPE* internal_default_instance() {
    return reinterpret_cast<const PIPE*>(
               &_PIPE_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PIPE* other);
  friend void swap(PIPE& a, PIPE& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PIPE* New() const PROTOBUF_FINAL { return New(NULL); }

  PIPE* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PIPE& from);
  void MergeFrom(const PIPE& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PIPE* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double Coordinates = 3;
  int coordinates_size() const;
  void clear_coordinates();
  static const int kCoordinatesFieldNumber = 3;
  double coordinates(int index) const;
  void set_coordinates(int index, double value);
  void add_coordinates(double value);
  const ::google::protobuf::RepeatedField< double >&
      coordinates() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_coordinates();

  // repeated double Attitudes = 4;
  int attitudes_size() const;
  void clear_attitudes();
  static const int kAttitudesFieldNumber = 4;
  double attitudes(int index) const;
  void set_attitudes(int index, double value);
  void add_attitudes(double value);
  const ::google::protobuf::RepeatedField< double >&
      attitudes() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_attitudes();

  // optional string LayerName = 31;
  bool has_layername() const;
  void clear_layername();
  static const int kLayerNameFieldNumber = 31;
  const ::std::string& layername() const;
  void set_layername(const ::std::string& value);
  #if LANG_CXX11
  void set_layername(::std::string&& value);
  #endif
  void set_layername(const char* value);
  void set_layername(const char* value, size_t size);
  ::std::string* mutable_layername();
  ::std::string* release_layername();
  void set_allocated_layername(::std::string* layername);

  // optional string NewFeatureID = 32;
  bool has_newfeatureid() const;
  void clear_newfeatureid();
  static const int kNewFeatureIDFieldNumber = 32;
  const ::std::string& newfeatureid() const;
  void set_newfeatureid(const ::std::string& value);
  #if LANG_CXX11
  void set_newfeatureid(::std::string&& value);
  #endif
  void set_newfeatureid(const char* value);
  void set_newfeatureid(const char* value, size_t size);
  ::std::string* mutable_newfeatureid();
  ::std::string* release_newfeatureid();
  void set_allocated_newfeatureid(::std::string* newfeatureid);

  // optional string NewStartPointID = 33;
  bool has_newstartpointid() const;
  void clear_newstartpointid();
  static const int kNewStartPointIDFieldNumber = 33;
  const ::std::string& newstartpointid() const;
  void set_newstartpointid(const ::std::string& value);
  #if LANG_CXX11
  void set_newstartpointid(::std::string&& value);
  #endif
  void set_newstartpointid(const char* value);
  void set_newstartpointid(const char* value, size_t size);
  ::std::string* mutable_newstartpointid();
  ::std::string* release_newstartpointid();
  void set_allocated_newstartpointid(::std::string* newstartpointid);

  // optional string NewEndPointID = 34;
  bool has_newendpointid() const;
  void clear_newendpointid();
  static const int kNewEndPointIDFieldNumber = 34;
  const ::std::string& newendpointid() const;
  void set_newendpointid(const ::std::string& value);
  #if LANG_CXX11
  void set_newendpointid(::std::string&& value);
  #endif
  void set_newendpointid(const char* value);
  void set_newendpointid(const char* value, size_t size);
  ::std::string* mutable_newendpointid();
  ::std::string* release_newendpointid();
  void set_allocated_newendpointid(::std::string* newendpointid);

  // required uint64 FeatureID = 1;
  bool has_featureid() const;
  void clear_featureid();
  static const int kFeatureIDFieldNumber = 1;
  ::google::protobuf::uint64 featureid() const;
  void set_featureid(::google::protobuf::uint64 value);

  // optional uint64 SymbolID = 11 [default = 0];
  bool has_symbolid() const;
  void clear_symbolid();
  static const int kSymbolIDFieldNumber = 11;
  ::google::protobuf::uint64 symbolid() const;
  void set_symbolid(::google::protobuf::uint64 value);

  // required .GEOPIPEMODEL.enumGeometryType GeometryType = 2;
  bool has_geometrytype() const;
  void clear_geometrytype();
  static const int kGeometryTypeFieldNumber = 2;
  ::GEOPIPEMODEL::enumGeometryType geometrytype() const;
  void set_geometrytype(::GEOPIPEMODEL::enumGeometryType value);

  // optional .GEOPIPEMODEL.enumScetionType ScetionType = 23;
  bool has_scetiontype() const;
  void clear_scetiontype();
  static const int kScetionTypeFieldNumber = 23;
  ::GEOPIPEMODEL::enumScetionType scetiontype() const;
  void set_scetiontype(::GEOPIPEMODEL::enumScetionType value);

  // optional uint64 StartPointID = 21 [default = 0];
  bool has_startpointid() const;
  void clear_startpointid();
  static const int kStartPointIDFieldNumber = 21;
  ::google::protobuf::uint64 startpointid() const;
  void set_startpointid(::google::protobuf::uint64 value);

  // optional uint64 EndPointID = 22 [default = 0];
  bool has_endpointid() const;
  void clear_endpointid();
  static const int kEndPointIDFieldNumber = 22;
  ::google::protobuf::uint64 endpointid() const;
  void set_endpointid(::google::protobuf::uint64 value);

  // optional double Caliber = 24 [default = 0];
  bool has_caliber() const;
  void clear_caliber();
  static const int kCaliberFieldNumber = 24;
  double caliber() const;
  void set_caliber(double value);

  // optional double Height = 25 [default = 0];
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 25;
  double height() const;
  void set_height(double value);

  // optional double Width = 26 [default = 0];
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 26;
  double width() const;
  void set_width(double value);

  // @@protoc_insertion_point(class_scope:GEOPIPEMODEL.PIPE)
 private:
  void set_has_featureid();
  void clear_has_featureid();
  void set_has_geometrytype();
  void clear_has_geometrytype();
  void set_has_symbolid();
  void clear_has_symbolid();
  void set_has_startpointid();
  void clear_has_startpointid();
  void set_has_endpointid();
  void clear_has_endpointid();
  void set_has_scetiontype();
  void clear_has_scetiontype();
  void set_has_caliber();
  void clear_has_caliber();
  void set_has_height();
  void clear_has_height();
  void set_has_width();
  void clear_has_width();
  void set_has_layername();
  void clear_has_layername();
  void set_has_newfeatureid();
  void clear_has_newfeatureid();
  void set_has_newstartpointid();
  void clear_has_newstartpointid();
  void set_has_newendpointid();
  void clear_has_newendpointid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > coordinates_;
  ::google::protobuf::RepeatedField< double > attitudes_;
  ::google::protobuf::internal::ArenaStringPtr layername_;
  ::google::protobuf::internal::ArenaStringPtr newfeatureid_;
  ::google::protobuf::internal::ArenaStringPtr newstartpointid_;
  ::google::protobuf::internal::ArenaStringPtr newendpointid_;
  ::google::protobuf::uint64 featureid_;
  ::google::protobuf::uint64 symbolid_;
  int geometrytype_;
  int scetiontype_;
  ::google::protobuf::uint64 startpointid_;
  ::google::protobuf::uint64 endpointid_;
  double caliber_;
  double height_;
  double width_;
  friend struct protobuf_GeoPipeModel_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringTable : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GEOPIPEMODEL.StringTable) */ {
 public:
  StringTable();
  virtual ~StringTable();

  StringTable(const StringTable& from);

  inline StringTable& operator=(const StringTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringTable(StringTable&& from) noexcept
    : StringTable() {
    *this = ::std::move(from);
  }

  inline StringTable& operator=(StringTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StringTable& default_instance();

  static inline const StringTable* internal_default_instance() {
    return reinterpret_cast<const StringTable*>(
               &_StringTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(StringTable* other);
  friend void swap(StringTable& a, StringTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringTable* New() const PROTOBUF_FINAL { return New(NULL); }

  StringTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const StringTable& from);
  void MergeFrom(const StringTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string s = 1;
  int s_size() const;
  void clear_s();
  static const int kSFieldNumber = 1;
  const ::std::string& s(int index) const;
  ::std::string* mutable_s(int index);
  void set_s(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_s(int index, ::std::string&& value);
  #endif
  void set_s(int index, const char* value);
  void set_s(int index, const char* value, size_t size);
  ::std::string* add_s();
  void add_s(const ::std::string& value);
  #if LANG_CXX11
  void add_s(::std::string&& value);
  #endif
  void add_s(const char* value);
  void add_s(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& s() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_s();

  // @@protoc_insertion_point(class_scope:GEOPIPEMODEL.StringTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> s_;
  friend struct protobuf_GeoPipeModel_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PIPETile : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GEOPIPEMODEL.PIPETile) */ {
 public:
  PIPETile();
  virtual ~PIPETile();

  PIPETile(const PIPETile& from);

  inline PIPETile& operator=(const PIPETile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PIPETile(PIPETile&& from) noexcept
    : PIPETile() {
    *this = ::std::move(from);
  }

  inline PIPETile& operator=(PIPETile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PIPETile& default_instance();

  static inline const PIPETile* internal_default_instance() {
    return reinterpret_cast<const PIPETile*>(
               &_PIPETile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PIPETile* other);
  friend void swap(PIPETile& a, PIPETile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PIPETile* New() const PROTOBUF_FINAL { return New(NULL); }

  PIPETile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PIPETile& from);
  void MergeFrom(const PIPETile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PIPETile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .GEOPIPEMODEL.PIPE PIPES = 4;
  int pipes_size() const;
  void clear_pipes();
  static const int kPIPESFieldNumber = 4;
  const ::GEOPIPEMODEL::PIPE& pipes(int index) const;
  ::GEOPIPEMODEL::PIPE* mutable_pipes(int index);
  ::GEOPIPEMODEL::PIPE* add_pipes();
  ::google::protobuf::RepeatedPtrField< ::GEOPIPEMODEL::PIPE >*
      mutable_pipes();
  const ::google::protobuf::RepeatedPtrField< ::GEOPIPEMODEL::PIPE >&
      pipes() const;

  // required .GEOPIPEMODEL.StringTable StringTable = 3;
  bool has_stringtable() const;
  void clear_stringtable();
  static const int kStringTableFieldNumber = 3;
  const ::GEOPIPEMODEL::StringTable& stringtable() const;
  ::GEOPIPEMODEL::StringTable* mutable_stringtable();
  ::GEOPIPEMODEL::StringTable* release_stringtable();
  void set_allocated_stringtable(::GEOPIPEMODEL::StringTable* stringtable);

  // required int64 Version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // required int64 TileKey = 2;
  bool has_tilekey() const;
  void clear_tilekey();
  static const int kTileKeyFieldNumber = 2;
  ::google::protobuf::int64 tilekey() const;
  void set_tilekey(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GEOPIPEMODEL.PIPETile)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_tilekey();
  void clear_has_tilekey();
  void set_has_stringtable();
  void clear_has_stringtable();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::GEOPIPEMODEL::PIPE > pipes_;
  ::GEOPIPEMODEL::StringTable* stringtable_;
  ::google::protobuf::int64 version_;
  ::google::protobuf::int64 tilekey_;
  friend struct protobuf_GeoPipeModel_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PIPE

// required uint64 FeatureID = 1;
inline bool PIPE::has_featureid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PIPE::set_has_featureid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PIPE::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PIPE::clear_featureid() {
  featureid_ = GOOGLE_ULONGLONG(0);
  clear_has_featureid();
}
inline ::google::protobuf::uint64 PIPE::featureid() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.FeatureID)
  return featureid_;
}
inline void PIPE::set_featureid(::google::protobuf::uint64 value) {
  set_has_featureid();
  featureid_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.FeatureID)
}

// required .GEOPIPEMODEL.enumGeometryType GeometryType = 2;
inline bool PIPE::has_geometrytype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PIPE::set_has_geometrytype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PIPE::clear_has_geometrytype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PIPE::clear_geometrytype() {
  geometrytype_ = 0;
  clear_has_geometrytype();
}
inline ::GEOPIPEMODEL::enumGeometryType PIPE::geometrytype() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.GeometryType)
  return static_cast< ::GEOPIPEMODEL::enumGeometryType >(geometrytype_);
}
inline void PIPE::set_geometrytype(::GEOPIPEMODEL::enumGeometryType value) {
  assert(::GEOPIPEMODEL::enumGeometryType_IsValid(value));
  set_has_geometrytype();
  geometrytype_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.GeometryType)
}

// repeated double Coordinates = 3;
inline int PIPE::coordinates_size() const {
  return coordinates_.size();
}
inline void PIPE::clear_coordinates() {
  coordinates_.Clear();
}
inline double PIPE::coordinates(int index) const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.Coordinates)
  return coordinates_.Get(index);
}
inline void PIPE::set_coordinates(int index, double value) {
  coordinates_.Set(index, value);
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.Coordinates)
}
inline void PIPE::add_coordinates(double value) {
  coordinates_.Add(value);
  // @@protoc_insertion_point(field_add:GEOPIPEMODEL.PIPE.Coordinates)
}
inline const ::google::protobuf::RepeatedField< double >&
PIPE::coordinates() const {
  // @@protoc_insertion_point(field_list:GEOPIPEMODEL.PIPE.Coordinates)
  return coordinates_;
}
inline ::google::protobuf::RepeatedField< double >*
PIPE::mutable_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:GEOPIPEMODEL.PIPE.Coordinates)
  return &coordinates_;
}

// repeated double Attitudes = 4;
inline int PIPE::attitudes_size() const {
  return attitudes_.size();
}
inline void PIPE::clear_attitudes() {
  attitudes_.Clear();
}
inline double PIPE::attitudes(int index) const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.Attitudes)
  return attitudes_.Get(index);
}
inline void PIPE::set_attitudes(int index, double value) {
  attitudes_.Set(index, value);
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.Attitudes)
}
inline void PIPE::add_attitudes(double value) {
  attitudes_.Add(value);
  // @@protoc_insertion_point(field_add:GEOPIPEMODEL.PIPE.Attitudes)
}
inline const ::google::protobuf::RepeatedField< double >&
PIPE::attitudes() const {
  // @@protoc_insertion_point(field_list:GEOPIPEMODEL.PIPE.Attitudes)
  return attitudes_;
}
inline ::google::protobuf::RepeatedField< double >*
PIPE::mutable_attitudes() {
  // @@protoc_insertion_point(field_mutable_list:GEOPIPEMODEL.PIPE.Attitudes)
  return &attitudes_;
}

// optional uint64 SymbolID = 11 [default = 0];
inline bool PIPE::has_symbolid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PIPE::set_has_symbolid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PIPE::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PIPE::clear_symbolid() {
  symbolid_ = GOOGLE_ULONGLONG(0);
  clear_has_symbolid();
}
inline ::google::protobuf::uint64 PIPE::symbolid() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.SymbolID)
  return symbolid_;
}
inline void PIPE::set_symbolid(::google::protobuf::uint64 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.SymbolID)
}

// optional uint64 StartPointID = 21 [default = 0];
inline bool PIPE::has_startpointid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PIPE::set_has_startpointid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PIPE::clear_has_startpointid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PIPE::clear_startpointid() {
  startpointid_ = GOOGLE_ULONGLONG(0);
  clear_has_startpointid();
}
inline ::google::protobuf::uint64 PIPE::startpointid() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.StartPointID)
  return startpointid_;
}
inline void PIPE::set_startpointid(::google::protobuf::uint64 value) {
  set_has_startpointid();
  startpointid_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.StartPointID)
}

// optional uint64 EndPointID = 22 [default = 0];
inline bool PIPE::has_endpointid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PIPE::set_has_endpointid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PIPE::clear_has_endpointid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PIPE::clear_endpointid() {
  endpointid_ = GOOGLE_ULONGLONG(0);
  clear_has_endpointid();
}
inline ::google::protobuf::uint64 PIPE::endpointid() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.EndPointID)
  return endpointid_;
}
inline void PIPE::set_endpointid(::google::protobuf::uint64 value) {
  set_has_endpointid();
  endpointid_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.EndPointID)
}

// optional .GEOPIPEMODEL.enumScetionType ScetionType = 23;
inline bool PIPE::has_scetiontype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PIPE::set_has_scetiontype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PIPE::clear_has_scetiontype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PIPE::clear_scetiontype() {
  scetiontype_ = 0;
  clear_has_scetiontype();
}
inline ::GEOPIPEMODEL::enumScetionType PIPE::scetiontype() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.ScetionType)
  return static_cast< ::GEOPIPEMODEL::enumScetionType >(scetiontype_);
}
inline void PIPE::set_scetiontype(::GEOPIPEMODEL::enumScetionType value) {
  assert(::GEOPIPEMODEL::enumScetionType_IsValid(value));
  set_has_scetiontype();
  scetiontype_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.ScetionType)
}

// optional double Caliber = 24 [default = 0];
inline bool PIPE::has_caliber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PIPE::set_has_caliber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PIPE::clear_has_caliber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PIPE::clear_caliber() {
  caliber_ = 0;
  clear_has_caliber();
}
inline double PIPE::caliber() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.Caliber)
  return caliber_;
}
inline void PIPE::set_caliber(double value) {
  set_has_caliber();
  caliber_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.Caliber)
}

// optional double Height = 25 [default = 0];
inline bool PIPE::has_height() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PIPE::set_has_height() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PIPE::clear_has_height() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PIPE::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double PIPE::height() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.Height)
  return height_;
}
inline void PIPE::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.Height)
}

// optional double Width = 26 [default = 0];
inline bool PIPE::has_width() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PIPE::set_has_width() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PIPE::clear_has_width() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PIPE::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double PIPE::width() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.Width)
  return width_;
}
inline void PIPE::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.Width)
}

// optional string LayerName = 31;
inline bool PIPE::has_layername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PIPE::set_has_layername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PIPE::clear_has_layername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PIPE::clear_layername() {
  layername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_layername();
}
inline const ::std::string& PIPE::layername() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.LayerName)
  return layername_.GetNoArena();
}
inline void PIPE::set_layername(const ::std::string& value) {
  set_has_layername();
  layername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.LayerName)
}
#if LANG_CXX11
inline void PIPE::set_layername(::std::string&& value) {
  set_has_layername();
  layername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GEOPIPEMODEL.PIPE.LayerName)
}
#endif
inline void PIPE::set_layername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_layername();
  layername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GEOPIPEMODEL.PIPE.LayerName)
}
inline void PIPE::set_layername(const char* value, size_t size) {
  set_has_layername();
  layername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GEOPIPEMODEL.PIPE.LayerName)
}
inline ::std::string* PIPE::mutable_layername() {
  set_has_layername();
  // @@protoc_insertion_point(field_mutable:GEOPIPEMODEL.PIPE.LayerName)
  return layername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PIPE::release_layername() {
  // @@protoc_insertion_point(field_release:GEOPIPEMODEL.PIPE.LayerName)
  clear_has_layername();
  return layername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PIPE::set_allocated_layername(::std::string* layername) {
  if (layername != NULL) {
    set_has_layername();
  } else {
    clear_has_layername();
  }
  layername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layername);
  // @@protoc_insertion_point(field_set_allocated:GEOPIPEMODEL.PIPE.LayerName)
}

// optional string NewFeatureID = 32;
inline bool PIPE::has_newfeatureid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PIPE::set_has_newfeatureid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PIPE::clear_has_newfeatureid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PIPE::clear_newfeatureid() {
  newfeatureid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_newfeatureid();
}
inline const ::std::string& PIPE::newfeatureid() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.NewFeatureID)
  return newfeatureid_.GetNoArena();
}
inline void PIPE::set_newfeatureid(const ::std::string& value) {
  set_has_newfeatureid();
  newfeatureid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.NewFeatureID)
}
#if LANG_CXX11
inline void PIPE::set_newfeatureid(::std::string&& value) {
  set_has_newfeatureid();
  newfeatureid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GEOPIPEMODEL.PIPE.NewFeatureID)
}
#endif
inline void PIPE::set_newfeatureid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_newfeatureid();
  newfeatureid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GEOPIPEMODEL.PIPE.NewFeatureID)
}
inline void PIPE::set_newfeatureid(const char* value, size_t size) {
  set_has_newfeatureid();
  newfeatureid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GEOPIPEMODEL.PIPE.NewFeatureID)
}
inline ::std::string* PIPE::mutable_newfeatureid() {
  set_has_newfeatureid();
  // @@protoc_insertion_point(field_mutable:GEOPIPEMODEL.PIPE.NewFeatureID)
  return newfeatureid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PIPE::release_newfeatureid() {
  // @@protoc_insertion_point(field_release:GEOPIPEMODEL.PIPE.NewFeatureID)
  clear_has_newfeatureid();
  return newfeatureid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PIPE::set_allocated_newfeatureid(::std::string* newfeatureid) {
  if (newfeatureid != NULL) {
    set_has_newfeatureid();
  } else {
    clear_has_newfeatureid();
  }
  newfeatureid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newfeatureid);
  // @@protoc_insertion_point(field_set_allocated:GEOPIPEMODEL.PIPE.NewFeatureID)
}

// optional string NewStartPointID = 33;
inline bool PIPE::has_newstartpointid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PIPE::set_has_newstartpointid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PIPE::clear_has_newstartpointid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PIPE::clear_newstartpointid() {
  newstartpointid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_newstartpointid();
}
inline const ::std::string& PIPE::newstartpointid() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.NewStartPointID)
  return newstartpointid_.GetNoArena();
}
inline void PIPE::set_newstartpointid(const ::std::string& value) {
  set_has_newstartpointid();
  newstartpointid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.NewStartPointID)
}
#if LANG_CXX11
inline void PIPE::set_newstartpointid(::std::string&& value) {
  set_has_newstartpointid();
  newstartpointid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GEOPIPEMODEL.PIPE.NewStartPointID)
}
#endif
inline void PIPE::set_newstartpointid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_newstartpointid();
  newstartpointid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GEOPIPEMODEL.PIPE.NewStartPointID)
}
inline void PIPE::set_newstartpointid(const char* value, size_t size) {
  set_has_newstartpointid();
  newstartpointid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GEOPIPEMODEL.PIPE.NewStartPointID)
}
inline ::std::string* PIPE::mutable_newstartpointid() {
  set_has_newstartpointid();
  // @@protoc_insertion_point(field_mutable:GEOPIPEMODEL.PIPE.NewStartPointID)
  return newstartpointid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PIPE::release_newstartpointid() {
  // @@protoc_insertion_point(field_release:GEOPIPEMODEL.PIPE.NewStartPointID)
  clear_has_newstartpointid();
  return newstartpointid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PIPE::set_allocated_newstartpointid(::std::string* newstartpointid) {
  if (newstartpointid != NULL) {
    set_has_newstartpointid();
  } else {
    clear_has_newstartpointid();
  }
  newstartpointid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newstartpointid);
  // @@protoc_insertion_point(field_set_allocated:GEOPIPEMODEL.PIPE.NewStartPointID)
}

// optional string NewEndPointID = 34;
inline bool PIPE::has_newendpointid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PIPE::set_has_newendpointid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PIPE::clear_has_newendpointid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PIPE::clear_newendpointid() {
  newendpointid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_newendpointid();
}
inline const ::std::string& PIPE::newendpointid() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPE.NewEndPointID)
  return newendpointid_.GetNoArena();
}
inline void PIPE::set_newendpointid(const ::std::string& value) {
  set_has_newendpointid();
  newendpointid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPE.NewEndPointID)
}
#if LANG_CXX11
inline void PIPE::set_newendpointid(::std::string&& value) {
  set_has_newendpointid();
  newendpointid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GEOPIPEMODEL.PIPE.NewEndPointID)
}
#endif
inline void PIPE::set_newendpointid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_newendpointid();
  newendpointid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GEOPIPEMODEL.PIPE.NewEndPointID)
}
inline void PIPE::set_newendpointid(const char* value, size_t size) {
  set_has_newendpointid();
  newendpointid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GEOPIPEMODEL.PIPE.NewEndPointID)
}
inline ::std::string* PIPE::mutable_newendpointid() {
  set_has_newendpointid();
  // @@protoc_insertion_point(field_mutable:GEOPIPEMODEL.PIPE.NewEndPointID)
  return newendpointid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PIPE::release_newendpointid() {
  // @@protoc_insertion_point(field_release:GEOPIPEMODEL.PIPE.NewEndPointID)
  clear_has_newendpointid();
  return newendpointid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PIPE::set_allocated_newendpointid(::std::string* newendpointid) {
  if (newendpointid != NULL) {
    set_has_newendpointid();
  } else {
    clear_has_newendpointid();
  }
  newendpointid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newendpointid);
  // @@protoc_insertion_point(field_set_allocated:GEOPIPEMODEL.PIPE.NewEndPointID)
}

// -------------------------------------------------------------------

// StringTable

// repeated string s = 1;
inline int StringTable::s_size() const {
  return s_.size();
}
inline void StringTable::clear_s() {
  s_.Clear();
}
inline const ::std::string& StringTable::s(int index) const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.StringTable.s)
  return s_.Get(index);
}
inline ::std::string* StringTable::mutable_s(int index) {
  // @@protoc_insertion_point(field_mutable:GEOPIPEMODEL.StringTable.s)
  return s_.Mutable(index);
}
inline void StringTable::set_s(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.StringTable.s)
  s_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringTable::set_s(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.StringTable.s)
  s_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringTable::set_s(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  s_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GEOPIPEMODEL.StringTable.s)
}
inline void StringTable::set_s(int index, const char* value, size_t size) {
  s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GEOPIPEMODEL.StringTable.s)
}
inline ::std::string* StringTable::add_s() {
  // @@protoc_insertion_point(field_add_mutable:GEOPIPEMODEL.StringTable.s)
  return s_.Add();
}
inline void StringTable::add_s(const ::std::string& value) {
  s_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GEOPIPEMODEL.StringTable.s)
}
#if LANG_CXX11
inline void StringTable::add_s(::std::string&& value) {
  s_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:GEOPIPEMODEL.StringTable.s)
}
#endif
inline void StringTable::add_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  s_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GEOPIPEMODEL.StringTable.s)
}
inline void StringTable::add_s(const char* value, size_t size) {
  s_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GEOPIPEMODEL.StringTable.s)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringTable::s() const {
  // @@protoc_insertion_point(field_list:GEOPIPEMODEL.StringTable.s)
  return s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringTable::mutable_s() {
  // @@protoc_insertion_point(field_mutable_list:GEOPIPEMODEL.StringTable.s)
  return &s_;
}

// -------------------------------------------------------------------

// PIPETile

// required int64 Version = 1;
inline bool PIPETile::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PIPETile::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PIPETile::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PIPETile::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::int64 PIPETile::version() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPETile.Version)
  return version_;
}
inline void PIPETile::set_version(::google::protobuf::int64 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPETile.Version)
}

// required int64 TileKey = 2;
inline bool PIPETile::has_tilekey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PIPETile::set_has_tilekey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PIPETile::clear_has_tilekey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PIPETile::clear_tilekey() {
  tilekey_ = GOOGLE_LONGLONG(0);
  clear_has_tilekey();
}
inline ::google::protobuf::int64 PIPETile::tilekey() const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPETile.TileKey)
  return tilekey_;
}
inline void PIPETile::set_tilekey(::google::protobuf::int64 value) {
  set_has_tilekey();
  tilekey_ = value;
  // @@protoc_insertion_point(field_set:GEOPIPEMODEL.PIPETile.TileKey)
}

// required .GEOPIPEMODEL.StringTable StringTable = 3;
inline bool PIPETile::has_stringtable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PIPETile::set_has_stringtable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PIPETile::clear_has_stringtable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PIPETile::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::GEOPIPEMODEL::StringTable::Clear();
  clear_has_stringtable();
}
inline const ::GEOPIPEMODEL::StringTable& PIPETile::stringtable() const {
  const ::GEOPIPEMODEL::StringTable* p = stringtable_;
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPETile.StringTable)
  return p != NULL ? *p : *reinterpret_cast<const ::GEOPIPEMODEL::StringTable*>(
      &::GEOPIPEMODEL::_StringTable_default_instance_);
}
inline ::GEOPIPEMODEL::StringTable* PIPETile::mutable_stringtable() {
  set_has_stringtable();
  if (stringtable_ == NULL) {
    stringtable_ = new ::GEOPIPEMODEL::StringTable;
  }
  // @@protoc_insertion_point(field_mutable:GEOPIPEMODEL.PIPETile.StringTable)
  return stringtable_;
}
inline ::GEOPIPEMODEL::StringTable* PIPETile::release_stringtable() {
  // @@protoc_insertion_point(field_release:GEOPIPEMODEL.PIPETile.StringTable)
  clear_has_stringtable();
  ::GEOPIPEMODEL::StringTable* temp = stringtable_;
  stringtable_ = NULL;
  return temp;
}
inline void PIPETile::set_allocated_stringtable(::GEOPIPEMODEL::StringTable* stringtable) {
  delete stringtable_;
  stringtable_ = stringtable;
  if (stringtable) {
    set_has_stringtable();
  } else {
    clear_has_stringtable();
  }
  // @@protoc_insertion_point(field_set_allocated:GEOPIPEMODEL.PIPETile.StringTable)
}

// repeated .GEOPIPEMODEL.PIPE PIPES = 4;
inline int PIPETile::pipes_size() const {
  return pipes_.size();
}
inline void PIPETile::clear_pipes() {
  pipes_.Clear();
}
inline const ::GEOPIPEMODEL::PIPE& PIPETile::pipes(int index) const {
  // @@protoc_insertion_point(field_get:GEOPIPEMODEL.PIPETile.PIPES)
  return pipes_.Get(index);
}
inline ::GEOPIPEMODEL::PIPE* PIPETile::mutable_pipes(int index) {
  // @@protoc_insertion_point(field_mutable:GEOPIPEMODEL.PIPETile.PIPES)
  return pipes_.Mutable(index);
}
inline ::GEOPIPEMODEL::PIPE* PIPETile::add_pipes() {
  // @@protoc_insertion_point(field_add:GEOPIPEMODEL.PIPETile.PIPES)
  return pipes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::GEOPIPEMODEL::PIPE >*
PIPETile::mutable_pipes() {
  // @@protoc_insertion_point(field_mutable_list:GEOPIPEMODEL.PIPETile.PIPES)
  return &pipes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::GEOPIPEMODEL::PIPE >&
PIPETile::pipes() const {
  // @@protoc_insertion_point(field_list:GEOPIPEMODEL.PIPETile.PIPES)
  return pipes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace GEOPIPEMODEL

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::GEOPIPEMODEL::enumGeometryType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::GEOPIPEMODEL::enumScetionType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GeoPipeModel_2eproto__INCLUDED
